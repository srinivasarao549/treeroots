var c = clash().check,
    DIAGONAL_DIST_OF_1_COORD = 1.4142


//------ POINT->N -------//

describe("point_point", function(){

    it("should match exact values only", function(){
        
        var pointa = {x:1, y:2},
            pointb = {x:1.000001, y:2}
            
        expect(c.point_point(pointa, pointb)).toEqual(false)
        
        pointb = pointa
        
        expect(c.point_point(pointa, pointb)).toEqual(true)
        
    })

})

describe("point_circle", function(){
    
    it("should return true for any point within the circle", function(){
        var point = {x: 0, y: 0},
            circle = {x: 0, y: 0, radius: 1}
        
        expect(c.point_circle(point, circle)).toEqual(true)
        
        point.x = 0.5
        
        expect(c.point_circle(point, circle)).toEqual(true)
        
        point.y = 0.5
        
        expect(c.point_circle(point, circle)).toEqual(true)
        
    })
    
    it("should return false on edge of the circle", function(){
        var point = {x: 0, y: 0},
            circle = {x: 0, y: 0, radius: 1}
            
        point.x = circle.radius
        
        expect(c.point_circle(point, circle)).toEqual(false)
        
    })
    
    it("should return false outside of the circle", function(){
        var point = {x: 1, y: 1},
            circle = {x: 0, y: 0, radius: 1}
        
        expect(c.point_circle(point, circle)).toEqual(false)
        
    })
})

describe("point_aabb", function(){
    
    it("should return true for any point within the bb", function(){
        var point = {x: 0.1, y: 0.1},
            aabb = {x: 0, y: 0, width: 1, height: 1}
        
        expect(c.point_aabb(point, aabb)).toEqual(true)

    })
    
    it("should return false for any point on the edges or corners of the aabb", function(){
        
        // corners
        var point = {x: 0, y: 0},
            aabb = {x: 0, y: 0, width: 1, height: 1}
        
       expect(c.point_aabb(point, aabb)).toEqual(false)
       
       point.x = aabb.width
       
       expect(c.point_aabb(point, aabb)).toEqual(false)
       
       point.y = aabb.width
       
       expect(c.point_aabb(point, aabb)).toEqual(false)
       
       point.x = 0
       
       expect(c.point_aabb(point, aabb)).toEqual(false)
       
       // edges

       point = {x: 0, y: 0.5},

       expect(c.point_aabb(point, aabb)).toEqual(false)

       point.x = aabb.width

       expect(c.point_aabb(point, aabb)).toEqual(false)
       
       point = {x: 0.5, y: 1},

       expect(c.point_aabb(point, aabb)).toEqual(false)

       point.y = aabb.height

       expect(c.point_aabb(point, aabb)).toEqual(false)

    })
    
})
    

// point->pol
describe("point_poly", function(){

    it("should return true for any point within the poly", function(){
        var point = {x: 2, y: 2},
            poly = {vertices: [{x: 2, y: 1 },
                               {x: 1, y: 1.5},
                               {x: 1, y: 2.5},
                               {x: 2, y: 3 },
                               {x: 2, y: 3.5},   // test that this ignores, unlike the 'projected y' technique
                               {x: 3, y: 3.5},
                               {x: 4, y: 3},
                               {x: 4, y: 2},
                               {x: 3, y: 1}
                                ]}
        
        expect(c.point_poly(point, poly)).toEqual(true)
        
        // check right near an edge
        point = {x: 3.9, y: 2}
        
        expect(c.point_poly(point, poly)).toEqual(true)
        
        
        // should work fine on a reversed array
        poly.vertices.reverse()
        
         point = {x: 2, y: 2}
        
         expect(c.point_poly(point, poly)).toEqual(true)

         // check right near an edge
         point = {x: 3.9, y: 2}

         expect(c.point_poly(point, poly)).toEqual(true)
        
    })
    
    it("should return true for any point on the edges or outside of the poly", function(){
        
        var point = {x: 2.3, y: 1 },
            poly = {vertices: [{x: 2, y: 1 },
                               {x: 1, y: 1.5},
                               {x: 1, y: 2.5},
                               {x: 2, y: 3 },
                               {x: 2, y: 3.5},   // test that this ignores, unlike the 'projected y' technique
                               {x: 3, y: 3.5},
                               {x: 4, y: 3},
                               {x: 4, y: 2},
                               {x: 3, y: 1}
                                ]}
        
        expect(c.point_poly(point, poly)).toEqual(true)
        
        
    })
})
//------ CIRCLE->N -------//
